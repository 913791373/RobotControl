#include <Kalman.h>
#include <CurieBLE.h>
#include <CurieIMU.h>
#include <LiquidCrystal.h>

/*PORT MANIPULATION*/
uint32_t ioReg1=SS_GPIO_8B1_BASE_ADDR+SS_GPIO_EXT_PORTA;
uint32_t ioReg2=SOC_GPIO_BASE_ADDR+SOC_GPIO_EXT_PORTA;
uint32_t ioRegA=SS_GPIO_8B0_BASE_ADDR+SS_GPIO_EXT_PORTA;

/*PINS*/
#define EncoderB_right (__builtin_arc_lr(ioReg1)&0b00100000)  //Pin 8
#define EncoderB_left (__builtin_arc_lr(ioReg1)&0b01000000)   //Pin 9           pin_state = readPin2!=0;  0 for LOW; 1 for HIGH
#define EncoderA_right 11
#define EncoderA_left 10

#define M1_inA 4
#define M1_inB 2
#define M2_inA 7
#define M2_inB 3
#define M1_PWM 5    //left
#define M2_PWM 6    //right

#define BUTTON A5
#define VOLTAGE A4

/*VARIABLE SETTINGS*/
#define CALC_FREQ 800         //  Hz
#define SAMPLERATE 1600      //25, 50, 100, 200, 400, 800, 1600, 3200

//PID's for angle control - inner loop
float Kp = 60.0f;
float Ki = 2.5f;
float Kd = 0.9f;

//PID's for position control - outer loop
float KP = 0.8f;
float KI = 0.0f;
float KD = 0.8f;

float max_speed = 2.0f;
float max_turn = 50.0f;

/*VARIABLES FOR INTERRUPTS*/
volatile long ticks_L = 0, ticks_R = 0;

/*INITIALISE LCD LIBRARY*/
LiquidCrystal lcd(12, 13, A0, A1, A2, A3);
int lcdsize[] = {16, 2};

/*KALMAN CONFIGURATION*/
Kalman kalmanY;

/*RAW Values*/
int aRawX, aRawY, aRawZ;
int gRawX, gRawY, gRawZ;

/* IMU Data */
double accX, accY, accZ;
double gyroX, gyroY, gyroZ;
int16_t tempRaw;

double gyroXangle, gyroYangle; // Angle calculate using the gyro only
double compAngleX, compAngleY; // Calculated angle using a complementary filter
double kalAngleX, kalAngleY, kalAngleY_filt; // Calculated angle using a Kalman filter
int counter = 0;
uint32_t kal_timer;

/*BLUETOOTH CONFIGURATION*/
BLEPeripheral blePeripheral;
BLEService mService("00000000-0000-1000-8000-00805f9b34f0"); // create service

//BLEUnsignedCharCharacteristic --> send 1 unsigned char
BLEUnsignedCharCharacteristic turnCharacteristic("00000000-0000-1000-8000-00805f9b34f1", BLERead | BLEWrite);
BLEUnsignedCharCharacteristic speedCharacteristic("00000000-0000-1000-8000-00805f9b34f2", BLERead | BLEWrite);
BLEUnsignedCharCharacteristic tachAngleCharacteristic("00000000-0000-1000-8000-00805f9b34f3", BLERead | BLEWrite | BLENotify);
BLEUnsignedCharCharacteristic tachSpeedCharacteristic("00000000-0000-1000-8000-00805f9b34f4", BLERead | BLEWrite | BLENotify);

/*PROTOTYPES*/
float convertRawAcceleration(int aRaw);
float convertRawGyro(int gRaw);
void InterruptA_right();
void InterruptA_left();

void setup() {
  Serial.begin(9600);

/*START SENSOR READINGS & KALMAN*/
  // start the IMU and filter
  CurieIMU.begin();
  CurieIMU.setGyroRate(SAMPLERATE);
  CurieIMU.setAccelerometerRate(SAMPLERATE);

  // Set the accelerometer range to 2G
  CurieIMU.setAccelerometerRange(2);
  // Set the gyroscope range to 250 degrees/second
  CurieIMU.setGyroRange(250);
  CurieIMU.setGyroOffset(Y_AXIS, -0.33);
  
  CurieIMU.readMotionSensor(aRawX, aRawY, aRawZ, gRawX, gRawY, gRawZ);
  // convert from raw data to gravity and degrees/second units
  accX = convertRawAcceleration(aRawX);
  accZ = convertRawAcceleration(aRawZ);
  gyroY = convertRawGyro(gRawY);

  double pitch = atan2(-accX, accZ) * RAD_TO_DEG;
  kalmanY.setAngle(pitch);
  gyroYangle = pitch;
  compAngleY = pitch;

  kal_timer = micros();

  //declare I/O
  pinMode(BUTTON, INPUT);
  pinMode(8, INPUT_PULLUP);        //portmanipulation pin
  pinMode(9, INPUT_PULLUP);        //portmanipulation pin
  pinMode(2, OUTPUT);
  pinMode(3, OUTPUT);
  pinMode(4, OUTPUT);
  pinMode(7, OUTPUT);
  

  //set cursor position & message
  lcd.begin(lcdsize[0], lcdsize[1]);

  delay(500);

/*INITIALISE BLUETOOTH SERVICE*/
 // set the local name peripheral advertises
  blePeripheral.setLocalName("RobotSerivce");
  // set the UUID for the service this peripheral advertises:
  blePeripheral.setAdvertisedServiceUuid(mService.uuid());

  // add the characteristics to the service
  blePeripheral.addAttribute(mService);
  blePeripheral.addAttribute(speedCharacteristic);
  blePeripheral.addAttribute(turnCharacteristic);
  blePeripheral.addAttribute(tachAngleCharacteristic);
  blePeripheral.addAttribute(tachSpeedCharacteristic);

  speedCharacteristic.setValue(127); //start value == 0 speed
  turnCharacteristic.setValue(127);  //start value == 0 turn
  
  // start advertising
  blePeripheral.begin();  
  delay(500);
}

void loop() {

/*INITIALISE*/
  //Flags
  static boolean control = false;
  static boolean button_pressed = false;
  static boolean ble_connected = false;
  static boolean voltage_low = false;

  //Timer & Ticks
  static unsigned long int  stateTimer, voltageTimer, sensorTimer, bleTimer;
  static long ticks_right, ticks_left;

  //Control
  int unsigned calc_time = (int) (1000000/CALC_FREQ); //time in micros
  static float phi, e_phi,  e_phi_int, e_phi_der, phi_pid, phi_des;
  static float xdot, e_x, e_x_old, e_x_int, e_x_der, x_pid, x_des;
  static float x, dt;
  static float xdot_, phi_;     //vars for convertion to chars
  static float phi_old, x_old; 
  static float  u;              

  //Voltage Check
  static float voltage, voltage_old, voltage_div;
  static int i;

  //Motor Control
  static int duty_cycle_1 = 0, duty_cycle_2 = 0;

  //Ble Connection
  static unsigned char desired_speed_, desired_turn_, measured_speed, measured_angle;
  static float desired_speed, desired_turn;

  // poll for BLE events
  blePeripheral.poll();

  //Checks if the connection to the central is active or not
  BLECentral central = blePeripheral.central();

  attachInterrupt(EncoderA_right, InterruptA_right, RISING);
  attachInterrupt(EncoderA_left, InterruptA_left, RISING);

  //get Encoder and Sensor Data
  noInterrupts();
  ticks_right = ticks_R;
  ticks_left = ticks_L;
  CurieIMU.readMotionSensor(aRawX, aRawY, aRawZ, gRawX, gRawY, gRawZ);
  interrupts();

  // convert from raw data to gravity and degrees/second units
  accX = convertRawAcceleration(aRawX);
  accZ = convertRawAcceleration(aRawZ);
  gyroY = convertRawGyro(gRawY);


/*KALMAN FILTER*/
  double dt_kal = (double)(micros() - kal_timer) / 1000000; // Calculate delta time
  kal_timer = micros();

  // atan2 outputs the value of -π to π (radians) - see http://en.wikipedia.org/wiki/Atan2
  // It is then converted from radians to degrees
  double pitch = atan2(-accX, accZ) * RAD_TO_DEG;

  // This fixes the transition problem when the accelerometer angle jumps between -180 and 180 degrees
  if ((pitch < -90 && kalAngleY > 90) || (pitch > 90 && kalAngleY < -90)) {
    kalmanY.setAngle(pitch);
    compAngleY = pitch;
    kalAngleY = pitch;
    gyroYangle = pitch;
  } else
    kalAngleY = kalmanY.getAngle(pitch, gyroY, dt_kal); // Calculate the angle using a Kalman filter

/* alternative filters
*  gyroYangle += gyroY * dt_kal;
*  compAngleY = 0.93 * (compAngleY + gyroY * dt_kal) + 0.07 * pitch;
*/
  // Reset the gyro angle when it has drifted too much
  if (gyroYangle < -180 || gyroYangle > 180)
    gyroYangle = kalAngleY;

    kalAngleY -= 2.0f; //offset
    kalAngleY_filt += kalAngleY;
    counter++;

  /*LCD DISPLAY*/
  if(!control){
    if(!button_pressed){
      lcd.clear();
      lcd.print("Press Button");
      lcd.setCursor(0, 1);
      lcd.print("to start");
      while(!button_pressed){
          if(analogRead(BUTTON) > 900){
            button_pressed = true;
            lcd.clear();
          }
      }
    }
  else{
    lcd.setCursor(0, 0);
    lcd.print("Stand me up!");
    lcd.setCursor(0, 1);
    lcd.print(kalAngleY);
    //Serial.println(kalAngleY);
      if((kalAngleY < 0.1) && (kalAngleY > -0.1)){
          control = true;           //
        
          //Initialise/Start conditions
          ticks_L = 0;
          ticks_R = 0;
          x = 0;
          x_old = 0;
          x_des = 0;
          xdot = 0;
          e_x = 0;
          e_x_old = 0;
          e_x_int = 0;
          e_x_der = 0;
  
          phi_des = 0;
          phi = 0;
          e_phi = 0;
          e_phi_int = 0;
          e_phi_der = 0;
          
          desired_speed = 0;
          desired_speed_ = 0;
          desired_turn = 0;
          desired_turn_ = 0;
  
          kalAngleY_filt = 0;
          counter = 0;
         
          stateTimer = micros();
          voltageTimer = millis();
          sensorTimer = millis();
          bleTimer = millis();
          lcd.clear();
      }
    }
 }
  
/*CONTROL SEQUENCE*/
  else{
  
/*VOLTAGE CHECK*/
    if((millis() - voltageTimer) > 100){
      for(i = 0; i < 30; i++){
        if(i == 0){
          voltage_div = analogRead(VOLTAGE);
        }
        else{
         voltage_div += analogRead(VOLTAGE);
        }
      }
      voltage_div /= 30;
      voltage_div = voltage_div *(3.3f/1023);
      //voltage_div /= 10;
      voltage = voltage_div * (40.f/10);

      if(abs(voltage - voltage_old) > 0.05f){
        lcd.clear();
        lcd.print("Voltage: ");
        lcd.setCursor(9, 0);
        lcd.print(voltage);
        lcd.setCursor(0, 1);
        lcd.print("Go, go, go!");
        voltage_old = voltage;
        } 
      }
      if(voltage < 10.5f){
        lcd.clear();
        lcd.print("Please recharge");
        lcd.setCursor(0, 1);
        lcd.print("battery");
        voltage_low = true;
      }
  
/*PID CONTROL*/
  if((micros() - stateTimer) > calc_time){
    dt = (double) calc_time/1000000;
    x_des += desired_speed*dt;  //integrate speed setpoint

    x = (float) - 0.229f * 0.001 * (ticks_right+ticks_left); //[m] (1/(2*480)) * 70 *pi = 0.229 -- 480 counts/revolution
    e_x = x_des - x;

    e_x_int += e_x;
    e_x_der = (e_x - e_x_old)/dt; //[m/s]

    x_pid = KP * e_x + KI * e_x_int + KD * e_x_der;
    phi_des = constrain(x_pid, -6, 6);

    phi = - (kalAngleY_filt/counter);
    e_phi = phi_des - phi;
    e_phi_int += e_phi;
    e_phi_der = gyroY;
    
    phi_pid = Kp * e_phi + Ki * e_phi_int + Kd * e_phi_der;
    
    u = phi_pid;

    x_old = x;
    e_x_old = e_x;
    kalAngleY_filt = 0;
    counter = 0;

/*BLUETOOTH COMMUNICATION*/
    //convert data for ble
    phi_ = constrain(phi, -30, 30);
    xdot_ = constrain(xdot, -3, 3);
    phi_ = (phi_ + 30) *(255/61);
    xdot_ = (xdot_ + 3)*(255/7);
    measured_angle = (char) phi_;
    measured_speed = (char) xdot_;


    if((millis() - bleTimer) > 100){
      if(central && !voltage_low){
        desired_speed_ = speedCharacteristic.value();
        desired_turn_ = turnCharacteristic.value();
          
        desired_speed = (int) desired_speed_;
        desired_speed = (desired_speed - 127) * ((2*max_speed)/254);
    
        desired_turn = (int) desired_turn_;
        desired_turn = (int) ((desired_turn - 127) * ((2*max_turn)/254));


        Serial.print(central);
        Serial.print("\t\t");
        Serial.print(desired_speed);
        Serial.print("\t\t");
        Serial.println(desired_turn);
            
        tachSpeedCharacteristic.setValue(measured_speed);
        tachAngleCharacteristic.setValue(measured_angle);
      }
      else{
        desired_speed_ = 0;
        desired_turn_ = 0;
      }
      bleTimer = millis();
   }

/*MOTOR CONTROL*/
    duty_cycle_1 = (int) u + desired_turn; // * (255/22);
    duty_cycle_2 = (int) u - desired_turn;
     
    duty_cycle_1 = constrain(duty_cycle_1, -255, 255);
    duty_cycle_2 = constrain(duty_cycle_2, -255, 255);
  
    if(duty_cycle_1 >= 0){
      //forwards M1
      digitalWrite(M1_inA, HIGH);
      digitalWrite(M1_inB, LOW);
    }
    else{
      //backwards M1
      digitalWrite(M1_inA, LOW);
      digitalWrite(M1_inB, HIGH);
      duty_cycle_1 = -duty_cycle_1;
    }
    analogWrite(M1_PWM, duty_cycle_1); 
  
    if(duty_cycle_2 >= 0){
      //forwards M2
      digitalWrite(M2_inA, LOW);
      digitalWrite(M2_inB, HIGH);
    }
    else{
      //backwards M2
      digitalWrite(M2_inA, HIGH);
      digitalWrite(M2_inB, LOW);
      duty_cycle_2 = -duty_cycle_2;
    }
    analogWrite(M2_PWM, duty_cycle_2);
     
    //Robot has fallen down
    if((phi > 30) || (phi < -30)){
      control = false;
      button_pressed = false;
      //set PWM signals to 0
      analogWrite(M1_PWM, 0);  
      analogWrite(M2_PWM, 0); 
    }
    stateTimer = micros();
    }
  }
}//end of loop


/*FUNCTIONS*/
void InterruptA_right(){
  if(EncoderB_right!=0){
    ticks_R -= 1;
  }
  else{
    ticks_R += 1;
  }
}

void InterruptA_left(){
  if(EncoderB_left!=0){
    ticks_L += 1;
  }
  else{
    ticks_L -= 1;
  }
}

float convertRawAcceleration(int aRaw) {
  // since we are using 2G range
  // -2g maps to a raw value of -32768
  // +2g maps to a raw value of 32767
  
  float acc = (aRaw * 2.0) / 32768.0;
  return acc;
}

float convertRawGyro(int gRaw) {
  // since we are using 250 degrees/seconds range
  // -250 maps to a raw value of -32768
  // +250 maps to a raw value of 32767
  
  float gyro = (gRaw * 250.0) / 32768.0;
  return gyro;
}
